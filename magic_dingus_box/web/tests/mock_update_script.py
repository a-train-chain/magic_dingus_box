"""
Mock Update Script Generator.

Generates mock update.sh scripts for testing Flask endpoints
without running real updates.
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Optional


class MockUpdateScriptGenerator:
    """Generates mock update.sh scripts with configurable behavior."""

    def __init__(self, scripts_dir: Path):
        self.scripts_dir = scripts_dir
        self.scripts_dir.mkdir(parents=True, exist_ok=True)
        self.script_path = self.scripts_dir / "update.sh"

    def generate(
        self,
        current_version: str = "1.0.7",
        latest_version: str = "1.0.8",
        has_backup: bool = False,
        check_should_fail: bool = False,
        check_error_message: str = "Failed to connect to GitHub",
        install_should_fail: bool = False,
        install_fail_stage: str = "downloading",
        install_error_message: str = "Download failed",
        rollback_should_fail: bool = False,
        rollback_error_message: str = "No backup available for rollback",
        download_url: str = "https://github.com/a-train-chain/magic_dingus_box/releases/download/v{version}/release.tar.gz",
        release_notes: str = "Bug fixes and improvements",
        install_delay: float = 0.1,
    ) -> Path:
        """
        Generate a mock update.sh script with the specified behavior.

        Args:
            current_version: Current installed version
            latest_version: Latest available version
            has_backup: Whether a backup exists for rollback
            check_should_fail: Whether check command should fail
            check_error_message: Error message for failed check
            install_should_fail: Whether install command should fail
            install_fail_stage: Stage at which install fails
            install_error_message: Error message for failed install
            rollback_should_fail: Whether rollback command should fail
            rollback_error_message: Error message for failed rollback
            download_url: URL template for download (use {version} placeholder)
            release_notes: Release notes to include
            install_delay: Sleep duration during install (seconds)

        Returns:
            Path to the generated script
        """
        update_available = current_version != latest_version
        actual_download_url = download_url.format(version=latest_version)

        check_response = self._build_check_response(
            current_version=current_version,
            latest_version=latest_version,
            update_available=update_available,
            download_url=actual_download_url,
            release_notes=release_notes,
            has_backup=has_backup,
        )

        script_content = f'''#!/bin/bash
# Mock update script for testing
# Generated by MockUpdateScriptGenerator

case "$1" in
    check)
'''
        if check_should_fail:
            script_content += f'''        echo '{{"ok": false, "error": {{"message": "{check_error_message}"}}}}'
        exit 1
'''
        else:
            script_content += f'''        cat << 'EOF'
{json.dumps(check_response, indent=4)}
EOF
'''

        script_content += '''        ;;
    install)
'''
        if install_should_fail:
            script_content += f'''        echo '{{"ok": true, "stage": "preparing", "progress": 5, "message": "Starting..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "{install_fail_stage}", "progress": 30, "message": "Working..."}}'
        sleep {install_delay}
        echo '{{"ok": false, "error": {{"message": "{install_error_message}"}}}}'
        exit 1
'''
        else:
            script_content += f'''        echo '{{"ok": true, "stage": "preparing", "progress": 5, "message": "Starting..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "downloading", "progress": 30, "message": "Downloading..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "installing", "progress": 60, "message": "Installing..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "building", "progress": 80, "message": "Building..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "complete", "progress": 100, "message": "Update complete!", "new_version": "'"$2"'"}}'
'''

        script_content += '''        ;;
    rollback)
'''
        if rollback_should_fail:
            script_content += f'''        echo '{{"ok": false, "error": {{"message": "{rollback_error_message}"}}}}'
        exit 1
'''
        else:
            backup_version = current_version  # Assume backup is current version before update
            script_content += f'''        echo '{{"ok": true, "stage": "stopping_services", "progress": 10, "message": "Stopping services..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "restoring", "progress": 50, "message": "Restoring backup..."}}'
        sleep {install_delay}
        echo '{{"ok": true, "stage": "complete", "progress": 100, "message": "Rollback complete!", "version": "{backup_version}"}}'
'''

        script_content += f'''        ;;
    version)
        echo "{current_version}"
        ;;
    *)
        echo "Usage: $0 {{check|install|rollback|version}}"
        exit 1
        ;;
esac
'''

        self.script_path.write_text(script_content)
        self.script_path.chmod(0o755)
        return self.script_path

    def _build_check_response(
        self,
        current_version: str,
        latest_version: str,
        update_available: bool,
        download_url: str,
        release_notes: str,
        has_backup: bool,
    ) -> dict:
        """Build the JSON response for the check command."""
        return {
            "ok": True,
            "data": {
                "current_version": current_version,
                "latest_version": latest_version,
                "update_available": update_available,
                "download_url": download_url if update_available else "",
                "release_notes": release_notes,
                "published_at": "2024-01-15T12:00:00Z",
                "has_backup": has_backup,
            }
        }


def create_mock_script(
    scripts_dir: Path,
    scenario: str = "update_available",
) -> Path:
    """
    Create a mock update script for a predefined scenario.

    Args:
        scripts_dir: Directory to create the script in
        scenario: One of:
            - "update_available": Update available, install succeeds
            - "up_to_date": No update available
            - "github_error": Check fails with GitHub error
            - "install_fails": Install fails during download
            - "no_backup": Rollback fails due to no backup
            - "with_backup": Has backup, rollback succeeds

    Returns:
        Path to the generated script
    """
    generator = MockUpdateScriptGenerator(scripts_dir)

    scenarios = {
        "update_available": dict(
            current_version="1.0.7",
            latest_version="1.0.8",
            has_backup=False,
        ),
        "up_to_date": dict(
            current_version="1.0.8",
            latest_version="1.0.8",
            has_backup=True,
        ),
        "github_error": dict(
            check_should_fail=True,
            check_error_message="Failed to connect to GitHub",
        ),
        "install_fails": dict(
            current_version="1.0.7",
            latest_version="1.0.8",
            install_should_fail=True,
            install_fail_stage="downloading",
            install_error_message="Download failed: connection reset",
        ),
        "no_backup": dict(
            current_version="1.0.7",
            latest_version="1.0.8",
            has_backup=False,
            rollback_should_fail=True,
            rollback_error_message="No backup available for rollback",
        ),
        "with_backup": dict(
            current_version="1.0.7",
            latest_version="1.0.8",
            has_backup=True,
            rollback_should_fail=False,
        ),
    }

    if scenario not in scenarios:
        raise ValueError(f"Unknown scenario: {scenario}. Available: {list(scenarios.keys())}")

    return generator.generate(**scenarios[scenario])


if __name__ == "__main__":
    # Example usage
    import tempfile

    with tempfile.TemporaryDirectory() as tmpdir:
        scripts_dir = Path(tmpdir) / "scripts"

        # Generate different scenarios
        for scenario in ["update_available", "up_to_date", "github_error", "install_fails", "no_backup"]:
            script = create_mock_script(scripts_dir, scenario)
            print(f"\n=== {scenario} ===")
            print(script.read_text()[:500] + "...")
